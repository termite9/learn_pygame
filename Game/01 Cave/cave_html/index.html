<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CAVE – 동굴비행 (HTML/Canvas, 고정 스텝 물리 수정)</title>
  <style>
    :root{
      --bg:#0b3d0b;      /* 배경(초록) */
      --wall:#0c0c0c;    /* 동굴 벽(검정) */
      --ship:#e6e6e6;    /* 비행선 */
      --accent:#38bdf8;  /* 포인트 컬러 */
      --text:#e9f5ff;    /* 글자 */
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b3d0b 0%,#0f540f 100%);color:var(--text);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Apple Color Emoji,Segoe UI Emoji;}
    .wrap{max-width:920px;margin:24px auto;padding:12px;}
    h1{font-size:20px;font-weight:700;margin:0 0 10px;opacity:.9;}
    .card{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:12px 14px;backdrop-filter: blur(6px);}
    canvas{display:block;width:100%;height:auto;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:var(--bg);outline:none}
    .hud{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:10px;font-size:14px;opacity:.95}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    button{appearance:none;border:1px solid rgba(255,255,255,.2);background:rgba(0,0,0,.35);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
    button:hover{border-color:var(--accent)}
    .hint{opacity:.8}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>#CAVE – 간단한 가로 스크롤 동굴 비행 (정상 동작 수정판)</h1>
      <canvas id="game" width="800" height="600" aria-label="CAVE game" tabindex="0"></canvas>
      <div class="hud">
        <div><strong>조작</strong>: 스페이스/클릭(터치) = 위로 가속 · R = 재시작 · P = 일시정지</div>
        <div class="btns">
          <button id="btnPause" title="P">일시정지</button>
          <button id="btnRestart" title="R">재시작</button>
        </div>
      </div>
      <div class="hint">원작(Pygame)의 10FPS 물리와 동일하게 고정 스텝으로 처리합니다. (이전 버전은 60FPS에서 가속이 과하게 누적되어 플레이가 어려웠습니다)</div>
    </div>
  </div>

  <script>
  // ===== 기본 설정 =====
  const W = 800, H = 600;
  const COL_W = 10;             // 한 칸 너비(원작 동일)
  const WALLS = 80;             // 칸 수(원작 동일)
  const STEP = 0.1;             // 0.1초(=10FPS) 고정 스텝
  const GRAVITY = 3;            // 원작: 키가 눌리지 않으면 +3
  const THRUST  = -3;           // 원작: 스페이스면 -3
  const SHIP_W = 80, SHIP_H = 80; // 충돌 판정 박스(원작과 유사)

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // 동굴의 "구멍" 배열 – 각 칸은 {x, top, bottom}
  let holes = [];
  // 상태 변수
  let slope = randInt(1,6); // 1~6 (처음엔 양수)
  let shipY = 250;          // 시작 y
  let velocity = 0;         // 세로 속도
  let score = 0;            // 점수
  let gameOver = false;
  let paused = false;
  let spaceDown = false;

  let lastTime = performance.now();
  let acc = 0; // 누적 시간(초)

  // 로컬 하이스코어
  const HS_KEY = 'cave_html_highscore_v2';
  let highscore = Number(localStorage.getItem(HS_KEY) || 0);

  // 초기 동굴 구성 (원작과 동일한 직사각형 구멍들)
  function initHoles(){
    holes.length = 0;
    for(let i=0;i<WALLS;i++){
      holes.push({x: i*COL_W, top: 100, bottom: 500});
    }
  }

  function reset(){
    initHoles();
    slope = randInt(1,6); // 시작은 양수
    shipY = 250;
    velocity = 0;
    score = 0;
    gameOver = false;
    paused = false;
    spaceDown = false;
    canvas.focus();
  }

  // 유틸
  function randInt(a,b){ return (Math.random()*(b-a+1)|0)+a; }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // 입력
  addEventListener('keydown', e=>{
    if(e.code === 'Space'){ spaceDown = true; e.preventDefault(); }
    if(e.key === 'r' || e.key === 'R') reset();
    if(e.key === 'p' || e.key === 'P') paused = !paused;
  });
  addEventListener('keyup', e=>{ if(e.code === 'Space') spaceDown = false; });

  // 마우스/터치도 스페이스처럼 동작
  addEventListener('pointerdown', ()=>{ spaceDown = true; });
  addEventListener('pointerup', ()=>{ spaceDown = false; });

  // 버튼
  document.getElementById('btnPause').onclick = ()=> paused = !paused;
  document.getElementById('btnRestart').onclick = reset;

  // 메인 루프 (렌더는 60FPS, 물리는 10FPS 고정)
  reset();
  requestAnimationFrame(loop);

  function loop(now){
    const dt = Math.min(0.25, (now - lastTime)/1000); // 초
    lastTime = now;
    if(!paused){
      acc += dt;
      while(acc >= STEP){
        updatePhysics();
        acc -= STEP;
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  function updatePhysics(){
    if(gameOver) return;

    // 점수: 고정 스텝마다 +10 (원작 그대로)
    score += 10;

    // 세로 속도 갱신 (원작의 정수 가속을 그대로)
    velocity += (spaceDown ? THRUST : GRAVITY);
    shipY += velocity;

    // 동굴 스크롤: 맨 끝을 복사해서 가공 후 뒤에 붙이고, 맨 앞을 제거
    const last = holes[holes.length-1];
    const edge = {x: last.x, top: last.top, bottom: last.bottom};

    // 기울기 적용을 시험
    const testTop = edge.top + slope;
    const testBottom = edge.bottom + slope;

    // 화면을 벗어나려 하면 방향 반전 + 구멍 축소 (inflate 0,-20)
    if(testTop <= 0 || testBottom >= H){
      slope = randInt(1,6) * (slope>0 ? -1 : 1);
      edge.top += 10;     // 위에서 10 줄임
      edge.bottom -= 10;  // 아래에서 10 줄임 (총 20 축소)
      // 최소 구멍 높이 안전장치(너무 빨리 막히는 상황 방지)
      if(edge.bottom - edge.top < 40){
        const mid = (edge.top + edge.bottom)/2;
        edge.top = mid - 20; edge.bottom = mid + 20;
      }
    }

    // 최종 이동/축소 반영
    edge.top = clamp(edge.top + slope, 0, H);
    edge.bottom = clamp(edge.bottom + slope, 0, H);
    edge.x += COL_W; // 오른쪽 끝 다음 칸

    holes.push(edge);
    holes.shift();
    // 전체 왼쪽으로 이동(한 칸)
    for(const h of holes) h.x -= COL_W;

    // 충돌 판정: 가장 왼쪽 칸과 충돌 검사 (원작과 동일 로직)
    const first = holes[0];
    if(first.top > shipY || first.bottom < shipY + SHIP_H){
      triggerGameOver();
    }

    // 과도한 이탈 보조 처리
    if(shipY < -SHIP_H*2 || shipY > H + SHIP_H*2){
      triggerGameOver();
    }
  }

  function triggerGameOver(){
    if(!gameOver){
      gameOver = true;
      highscore = Math.max(highscore, Math.floor(score));
      localStorage.setItem(HS_KEY, String(highscore));
    }
  }

  function draw(){
    // 배경(초록)
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg');
    ctx.fillRect(0,0,W,H);

    // 동굴 벽(검정) – 각 칸의 구멍을 제외한 상단/하단을 그린다
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall');
    for(const h of holes){
      // 상단 벽
      ctx.fillRect(h.x, 0, COL_W, h.top);
      // 하단 벽
      ctx.fillRect(h.x, h.bottom, COL_W, H - h.bottom);
    }

    // 비행선 (벡터 드로잉)
    const shipX = 8; // 원작은 x=0 부근
    drawShip(shipX, shipY);

    // 점수/하이스코어
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.font = 'bold 28px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.textAlign = 'right';
    ctx.fillText(`Score ${Math.floor(score)}`, W-16, 40);
    ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(`Best ${highscore}`, W-16, 62);

    // 게임 오버/일시정지 오버레이
    if(gameOver){
      drawBang(shipX + SHIP_W*0.5, shipY + SHIP_H*0.4);
      overlayMessage('GAME OVER', 'R: 재시작 · P: 일시정지 · 화면 클릭 후 스페이스로 상승');
    } else if(paused){
      overlayMessage('PAUSED', 'P: 재개 · R: 재시작');
    }
  }

  function overlayMessage(title, sub){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#e9f5ff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 56px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(title, W/2, H/2 - 8);
    ctx.font = '18px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(sub, W/2, H/2 + 24);
    ctx.restore();
  }

  function drawShip(x, y){
    const c = ctx;
    c.save();
    c.translate(x, y);

    // 본체
    c.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ship');
    c.strokeStyle = 'rgba(0,0,0,.35)';
    c.lineWidth = 2;
    c.beginPath();
    // 몸통(라운드 직사각형 느낌)
    c.moveTo(8, 10);
    c.lineTo(60, 10);
    c.quadraticCurveTo(76, 10, 76, 26);
    c.lineTo(76, 54);
    c.quadraticCurveTo(76, 70, 60, 70);
    c.lineTo(8, 70);
    c.quadraticCurveTo(-6, 40, 8, 10);
    c.closePath();
    c.fill(); c.stroke();

    // 노즐 화염 (spaceDown 시 표시)
    if(spaceDown && !gameOver){
      c.fillStyle = 'rgba(255,165,0,.9)';
      c.beginPath();
      c.moveTo(0, 36);
      c.lineTo(-18 + (Math.random()*4-2), 26 + (Math.random()*6-3));
      c.lineTo(0, 46);
      c.closePath();
      c.fill();
    }

    // 캐노피
    c.fillStyle = '#38bdf8';
    c.fillRect(46, 20, 20, 18);

    c.restore();
  }

  function drawBang(cx, cy){
    const c = ctx;
    c.save();
    c.translate(cx, cy);
    for(let i=0;i<16;i++){
      const ang = (i/16)*Math.PI*2;
      const r1 = 12 + Math.random()*4;
      const r2 = 28 + Math.random()*8;
      c.strokeStyle = `hsla(${(i*22)%360},100%,70%,.9)`;
      c.lineWidth = 2;
      c.beginPath();
      c.moveTo(Math.cos(ang)*r1, Math.sin(ang)*r1);
      c.lineTo(Math.cos(ang)*r2, Math.sin(ang)*r2);
      c.stroke();
    }
    c.restore();
  }
  </script>
</body>
</html>